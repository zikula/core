// Copyright Zikula Foundation, licensed MIT.
/**
 * @fileOverview Zikula namespace definition
 */
if (typeof Zikula === 'undefined') {
    /**
     * Zikula global object
     *
     * @namespace Zikula global object
     *
     * @borrows Zikula.Util.Gettext#getMessage as __
     * @borrows Zikula.Util.Gettext#getMessageFormatted as __f
     * @borrows Zikula.Util.Gettext#getPluralMessage as _n
     * @borrows Zikula.Util.Gettext#getPluralMessageFormatted as _fn
     */
    var Zikula = {};
}
if (typeof jQuery !== 'undefined') {
    jQuery.Zikula = Zikula;
}// Copyright Zikula Foundation, licensed MIT.
/**
 * @fileOverview Zikula language extensions.
 * @requires underscore
 */
(function() {
    /**
     * Namespace for Zikula language extensions.
     * All methods are exposed (and documented) as _ (underscore) methods.
     * Zikula utilize base underscore and underscore.string. Visit linked pages to get documentation.
     *
     * @exports Zikula.Lang as _
     * @class
     * @see <a href="http://underscorejs.org/">http://underscorejs.org/</a>
     * @see <a href="https://github.com/epeli/underscore.string">https://github.com/epeli/underscore.string</a>

     */
    Zikula.Lang = {};

    /**
     * Underscore setup - export Underscore.string to base Underscore
     */
    _.mixin(_.str.exports());

    // Rename and add string functions, overwritten by core underscore methods, to allow chaining.
    _.mixin(/** @lends _ */{
        /**
         * Alias for 'include' method from underscore.string, overwritten by underscore.
         *
         * @function
         * @see <a href="https://github.com/epeli/underscore.string#problems">https://github.com/epeli/underscore.string#problems</a>
         */
        stringInclude: _.str.include,
        /**
         * Alias for 'reverse' method from underscore.string, overwritten by underscore.
         *
         * @function
         * @see <a href="https://github.com/epeli/underscore.string#problems">https://github.com/epeli/underscore.string#problems</a>
         */
        stringReverse: _.str.reverse
    });

    /**
     * Checks if string is valid JSON.
     *
     * @example
     * Zikula.Lang.isJSON(string); // base syntax
     * _(string).isJSON(); // underscore syntax (recommended)
     *
     * _('foo').isJSON(); // returns false
     * _("[1, 2]").isJSON(); // returns true
     *
     * @param {String} string String to test
     * @return {Boolean}
     * @link http://api.prototypejs.org/language/String/prototype/isJSON/
     */
    Zikula.Lang.isJSON = function(string) {
        if (!string) {
            return false;
        }
        string = string.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@');
        string = string.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']');
        string = string.replace(/(?:^|:|,)(?:\s*\[)+/g, '');
        return (/^[\],:{}\s]*$/).test(string);
    };

    /**
     * Encode json data to url safe format.
     *
     * @example
     *  Zikula.Lang.urlSafeJsonEncode(data, json); // base syntax
     * _(data).urlSafeJsonEncode(json); // underscore syntax (recommended)
     *
     * _({foo: 'bar'}).urlSafeJsonEncode(true); // returns "%7B%22foo%22%3A%22bar%22%7D"
     *
     * @param {*}        data       Data to encode
     * @param {Boolean} [json=true] Should data be also encode to json
     *
     * @return {String} Encoded data
     */
    Zikula.Lang.urlSafeJsonEncode = function(data, json) {
        json = _(json).isUndefined() ? true : json;
        if (json) {
            data = JSON.stringify(data);
        }
        data = data.replace(/\+/g, '%20');
        return encodeURIComponent(data);
    };

    /**
     * Decode json data from url safe format.
     *
     * @example
     *  Zikula.Lang.urlSafeJsonDecode(data, json); // base syntax
     * _(data).urlSafeJsonDecode(json); // underscore syntax (recommended)
     *
     * _("%7B%22foo%22%3A%22bar%22%7D").urlSafeJsonDecode(true); // returns {foo:"bar"})
     *
     * @param {String}   data       Data to encode
     * @param {Boolean} [json=true] Should data be also decode from json
     *
     * @return {*} Decoded data
     */
    Zikula.Lang.urlSafeJsonDecode = function(data, json) {
        json = _(json).isUndefined() ? true : json;
        data = data.replace(/\+/g, '%20');
        data = decodeURIComponent(data);
        if (json) {
            data = JSON.parse(data);
        }
        return data;
    };


    /**
     * Merge two objects recursively.
     *
     * Copies all properties from source to destination object and returns new object.
     * If property exists in destination it is extended not overwritten
     *
     * @example
     *  Zikula.Lang.extendRecursive(destination, source); // base syntax
     * _(destination).extendRecursive(source); // underscore syntax (recommended)
     *
     * var a = {x: true, z: {za: true}},
     *     b = {y: false, z: {zb: false}},
     *     c;
     * c =  _(a).extendRecursive(b); // c is now {x:true, z:{za:true, zb:false}, y:false}
     *
     * @param {Object} destination Destination object
     * @param {Object} source      Source object
     *
     * @return {Object} Extended object
     */
    Zikula.Lang.extendRecursive = function(destination, source) {
        destination = destination || {};
        for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
                try {
                    if (source[prop].constructor === Object) {
                        destination[prop] = Zikula.Lang.extendRecursive(destination[prop], source[prop]);
                    } else {
                        destination[prop] = source[prop];
                    }
                } catch (e) {
                    destination[prop] = source[prop];
                }
            }
        }
        return destination;
    };

    /**
     * Returns nested property value.
     * Allows to easy get at once nested path without worrying about TypeError on undefined property in path chain.
     *
     * @example
     *  Zikula.Lang.objectGetPath(object, pathName, defaultValue); // base syntax
     * _(object).objectGetPath(pathName, defaultValue); // underscore syntax (recommended)
     *
     * _(Zikula).objectGetPath(pathName, 'Config.entrypoint'); // returns 'index.php'
     * _(Zikula).objectGetPath(pathName, ['Config', 'entrypoint']); // returns 'index.php'
     * _(Zikula).objectGetPath(pathName, 'this.path.does.not.exists'); // returns undefined
     * _(Zikula).objectGetPath(pathName, 'this.path.does.not.exists', 'default'); // returns 'default'
     *
     * @param {Object}          object          Object to search in
     * @param {String|Array}    pathName        Dot separated path (or array of parts), relative to object
     * @param {*}              [defaultValue]   Default value to return when result is undefined
     *
     * @return {*} Property value, default value or undefined.
     */
    Zikula.Lang.objectGetPath = function(object, pathName, defaultValue) {
        var prop,
            path = _(pathName).isArray() ? pathName : pathName.split('.'),
            last = path.pop();

        while ((prop = path.shift())) {
            object = object[prop];
            if (!_(object).isObject()) {
                return defaultValue;
            }
        }
        return _(object[last]).isUndefined() ? defaultValue : object[last];
    };

    /**
     * Sets nested property value. If properties in path chain does not exists - they are crated.
     *
     * @example
     *  Zikula.Lang.objectSetPath(object, pathName, value); // base syntax
     * _(object).objectSetPath(pathName, value); // underscore syntax (recommended)
     *
     * _(Zikula).objectSetPath('some.long.path.name', true); // {Zikula:{long:{path:{name:true}}}}
     *
     * @param {Object}          object      Base object
     * @param {String|Array}    pathName    Dot separated path (or array of parts), relative to object
     * @param {*}               value       Value to set
     *
     * @return {*} Last property in path chain (the one that has set the value)
     */
    Zikula.Lang.objectSetPath = function(object, pathName, value) {
        var prop,
            path = _(pathName).isArray() ? pathName : pathName.split('.'),
            last = path.pop();

        while ((prop = path.shift())) {
            object[prop] = object[prop] || {};
            object = object[prop];
        }
        return object[last] = value;
    };

    /**
     * Checks if object has property.
     * Allows to easy check at once nested path without worrying about TypeError on undefined property in path chain.
     *
     * @example
     *  Zikula.Lang.objectIssetPath(object, pathName); // base syntax
     * _(object).objectIssetPath(pathName); // underscore syntax (recommended)
     *
     * _(Zikula).objectIssetPath('Util.Cookie'); // returns true
     * _(Zikula).objectIssetPath('Util.Foo'); // returns false
     *
     * @param {Object}          object      Base object
     * @param {String|Array}    pathName    Dot separated path (or array of parts), relative to object
     *
     * @return {Boolean}
     */
    Zikula.Lang.objectIssetPath = function(object, pathName) {
        return !_(Zikula.Lang.objectGetPath(object, pathName)).isUndefined();
    };

    /**
     * Deletes nested property.
     *
     * @example
     *  Zikula.Lang.objectUnsetPath(object, pathName); // base syntax
     * _(object).objectUnsetPath(pathName); // underscore syntax (recommended)
     *
     * _(Zikula).objectUnsetPath('Config.foo'); // returns true
     * _(Zikula).objectUnsetPath('this.one.does.not.exists'); // returns true
     *
     * @param {Object}          object      Base object
     * @param {String|Array}    pathName    Dot separated path (or array of parts), relative to object
     *
     * @return {Boolean} True on success or if given property did not exist
     */
    Zikula.Lang.objectUnsetPath = function(object, pathName) {
        if (Zikula.Lang.objectIssetPath(object, pathName)) {
            var prop,
                path = _(pathName).isArray() ? pathName : pathName.split('.'),
                last = path.pop();
            while ((prop = path.shift())) {
                object = object[prop];
            }
            return (delete object[last]);
        } else {
            return true;
        }
    };

    // Export Zikula.Lang methods to underscore
    _.mixin(Zikula.Lang);

})();
// Copyright Zikula Foundation, licensed MIT.
/**
 * @fileOverview Class-based inheritance model for JavaScript
 * @requires core.js
 */
(function() {
    /**
     * Zikula.Class for managing class-based inheritance.<br />
     * It's based on Prototype's Class with some changes (the way of super method calls)
     * and the ability to call the constructor with a arguments list.
     *
     * @namespace Zikula.Class for managing class-based inheritance
     */
    Zikula.Class = (function() {
        var fnTest = /xyz/.test(function() {xyz;}) ? /\b_super\b/ : /.*/;

        /**
         * Creates a class and returns a constructor function for instances of the class.<br />
         * Calling returned constructor with "new" statement will create new class
         * instance and automatically invoke class's "init" method.<br />
         * Accepts two kind of params: <br />
         * - the first one - "superclass" - is optional and it can be other Zikula.Class to extend;
         *   if given - all its methods and properties are inherited by created class;
         *   one can access parent's methods calling "super" method (see examples)<br />
         * - other params are objects, which methods are copied to new class; if there's
         *   more then one object and method names are overlapping, later one take precedence.
         *
         * @example
         * // create base class
         * var Animal = Zikula.Class.create({
         *     init: function(name, sound) {
         *         this.name  = name;
         *         this.sound = sound;
         *     },
         *     speak: function() {
         *         alert(this.name + ' says: ' + this.sound + '!');
         *     }
         * });
         * // extend base class
         * var Snake = Zikula.Class.create(Animal, {
         *     init: function(name) {
         *         this._super('init', name, 'hissssssssss');
         *     }
         * });
         * // create instance
         * var ringneck = new Snake('Ringneck');
         * ringneck.speak(); // alerts "Ringneck says: hissssssss!"
         *
         * @name Zikula.Class.create
         * @static
         * @function
         *
         * @param {Zikula.Class} [superclass] Optional superclass to extend
         * @param {Object} methods     One or more objects with methods for new class
         *
         * @return {Zikula.Class} Zikula.Class constructor
         */
        function create() {
            'klass:nomunge'; // do not obfuscate constructor name
            var parent = null, args = Array.prototype.slice.call(arguments);
            if (typeof args[0] === 'function') {
                parent = args.shift();
            }

            function klass() {
                this.init.apply(this, arguments);
            }

            extend(klass, Methods);
            klass.superclass = parent;
            klass.subclasses = [];

            if (parent) {
                var subclass = function() {};
                subclass.prototype = parent.prototype;
                klass.prototype = new subclass();
                parent.subclasses.push(klass);
            }

            for (var i = 0; i < args.length; i++) {
                klass.addMethods(args[i]);
            }

            if (!klass.prototype.init) {
                klass.prototype.init = function() {};
            }

            klass.prototype.constructor = klass;

            return klass;
        }

        /**
         * Extends object by copying all properties from the source object to the destination object.<br />
         * By default source properties override destination properties, if such exists.
         * This can be avoided with safe param set to true.
         *
         * @example
         * // simple usage
         * var dest = {
         *         a: 1
         *     },
         *     source = {
         *         a: 2,
         *         b: true
         *     };
         * Zikula.Class.extend(dest, source, true); // dest is now {a: 1, b: true}
         *
         * // extend Animal class with some static method
         * Zikula.Class.extend(Animal, {
         *     staticProp: true,
         *     staticMethod: function() {
         *         alert('Animal.staticMethod called!');
         *     }
         * });
         * Animal.staticMethod(); // alerts "Animal.staticMethod called!"
         *
         * @name Zikula.Class.extend
         * @static
         * @function
         *
         * @param {Object}   dest        Destination object, where new properties will be copied
         * @param {Object}   source      Source object
         * @param {Boolean} [safe=false] If set to true, the destination object properties won't be overwritten
         *
         * @return {Object} Extended object
         */
        function extend(dest, source, safe) {
            safe = safe || false;
            for (var prop in source) {
                if (!dest[prop] || !safe) {
                    dest[prop] = source[prop];
                }
            }
            return dest;
        }

        /**
         * Calls class constructor with an arbitrary number of arguments.<br />
         * Allows to simulate use of .apply() on class constructor.
         *
         * @example
         * var args = ['some name', 'some sound'];
         * var instance = Zikula.Class.construct(Animal, args); // works the same as new Animal('some name', 'some sound');
         *
         * @name Zikula.Class.construct
         * @static
         * @function
         *
         * @param {Zikula.Class} klass Zikula.Class object
         * @param {*}     args  Arguments to pass to klass constructor
         *
         * @return {Zikula.Class} New instance of given klass
         */
        function construct(klass, args) {
            function F() {
                return klass.apply(this, args);
            }

            F.prototype = klass.prototype;
            return new F();
        }

        var privates = 'superclass subclasses addMethods getMethods hasMethod getStaticProperties hasStaticProperty'.split(' '),
            Methods = {
                /**
                 * Allows to add new (or redefine existing) instance methods.<br />
                 * This method is available on classes created by {@link Zikula.Class.create}.<br />
                 * New methods are added to all subclasses as well as the already instantiated instances.
                 *
                 * @example
                 * var Animal = Zikula.Class.create({
                 *     init: function(name, sound) {
                 *         this.name  = name;
                 *         this.sound = sound;
                 *     },
                 *     speak: function() {
                 *         alert(this.name + ' says: ' + this.sound + '!');
                 *     }
                 * });
                 * var Bird = Zikula.Class.create(Animal, {
                 *     init: function(sound) {
                 *         this._super('init', 'Bird', sound);
                 *     }
                 * });
                 * var littleBird = new Bird('Bird', 'tweet, tweet');
                 * Animal.addMethods({
                 *     speakLoud: function() {
                 *         alert(this.name + ' says: ' + this.sound.toUpperCase() + '!');
                 *     }
                 * });
                 * littleBird.speakLoud(); // alerts "Bird says: TWEET, TWEET!"
                 *
                 * @name Zikula.Class#addMethods
                 * @function
                 *
                 * @param {Object} source Source object containing methods to add
                 *
                 * @return {Zikula.Class}
                 */
                addMethods: function(source) {
                    var ancestor = this.superclass && this.superclass.prototype;

                    for (var name in source) {
                        this.prototype[name] = typeof source[name] === 'function' &&
                            ancestor && typeof ancestor[name] === 'function' && fnTest.test(source[name]) ? (function(name, fn) {
                            return function() {
                                this._super = function(method) {
                                    return ancestor[method].apply(this, Array.prototype.slice.call(arguments, 1));
                                };
                                return fn.apply(this, arguments);
                            };
                        })(name, source[name]) : source[name];
                    }

                    return this;
                },
                /**
                 * Gets the class methods' names.
                 *
                 * @example
                 * var Animal = Zikula.Class.create({
                 *     init: function(name, sound) {
                 *         this.name  = name;
                 *         this.sound = sound;
                 *     },
                 *     speak: function() {
                 *         alert(this.name + ' says: ' + this.sound + '!');
                 *     }
                 * });
                 * Animal.getMethods(); // returns ['init', 'speak']
                 *
                 * @name Zikula.Class#getMethods
                 * @function
                 *
                 * @return {Array} Array of class methods names
                 */
                getMethods: function() {
                    var methods = [];
                    for (var name in this.prototype) {
                        if (name !== 'constructor' && typeof this.prototype[name] === 'function') {
                            methods.push(name);
                        }
                    }
                    return methods;
                },
                /**
                 * Checks if the class method exists.
                 *
                 * @example
                 * var Animal = Zikula.Class.create({
                 *     init: function(name, sound) {
                 *         this.name  = name;
                 *         this.sound = sound;
                 *     },
                 *     speak: function() {
                 *         alert(this.name + ' says: ' + this.sound + '!');
                 *     }
                 * });
                 * Animal.hasMethod('speak'); // returns true
                 * Animal.hasMethod('speakQuietly'); // returns false
                 *
                 * @name Zikula.Class#hasMethod
                 * @function
                 *
                 * @param {String} name Method name to check
                 *
                 * @return {Boolean}
                 */
                hasMethod: function(name) {
                    return typeof this.prototype[name] === 'function';
                },
                /**
                 * Gets the class static properties names.<br />
                 * Internal properties and methods (such as superclass, subclasses etc) are ignored.
                 *
                 * @example
                 * Zikula.Class.extend(Animal, {
                 *     staticProp: true,
                 *     staticMethod: function() {
                 *         alert('Animal.staticMethod called!');
                 *     }
                 * });
                 * Animal.getStaticProperties(); // returns ['staticProp', 'staticMethod']
                 * Animal.hasMethod('speakQuietly'); // returns false
                 *
                 * @name Zikula.Class#getStaticProperties
                 * @function
                 *
                 * @return {Array} Array of class static properties
                 */
                getStaticProperties: function() {
                    var properties = [];
                    for (var name in this) {
                        if (privates.indexOf(name) === -1) {
                            properties.push(name);
                        }
                    }

                    return properties;
                },
                /**
                 * Checks if the class static property exists.
                 * Internal properties and methods (such as superclass, subclasses etc) are ignored.
                 *
                 * @example
                 * Zikula.Class.extend(Animal, {
                 *     staticProp: true,
                 *     staticMethod: function() {
                 *         alert('Animal.staticMethod called!');
                 *     }
                 *  });
                 * Animal.hasStaticProperty('staticMethod'); // returns true
                 * Animal.hasStaticProperty('speakQuietly'); // returns false
                 *
                 * @name Zikula.Class#hasStaticProperty
                 * @function
                 *
                 * @param {String} name Property name to check
                 *
                 * @return {Boolean}
                 */
                hasStaticProperty: function(name) {
                    return typeof this[name] !== 'undefined' && privates.indexOf(name) === -1;
                }
            };

        return {
            create: create,
            extend: extend,
            construct: construct
        };

    })();
})();// Copyright Zikula Foundation, licensed MIT.
/**
 * @fileOverview Zikula Core helper
 * @requires jQuery, underscore, Modernizr, lang.js, class.js
 */

(function($) {
    /**
     * Creates namespace in Zikula scope through nested chain of objects,
     * based on the given path.
     * If object in chain already exists it will be extended, not overwritten
     *
     * @example
     * Zikula.define('Module.Component'); //will create object chain: Zikula.Module.Component
     *
     * @param {String}  pathName        Dot separated path to define.
     *
     * @return {Object} Zikula extended object
     */
    Zikula.define = function(pathName) {
        if (Zikula.Lang.objectIssetPath(Zikula, pathName)) {
            return Zikula.Lang.objectGetPath(Zikula, pathName);
        }
        return Zikula.Lang.objectSetPath(Zikula, pathName, {});
    };

    /**
     * Namespace for Zikula Util classes
     *
     * @namespace
     * @name Zikula.Util
     */
    Zikula.define('Util');

    /**
     * Namespace for Zikula Services
     *
     * @name Zikula.Services
     * @namespace Zikula Plugins namespace
     * todo - move this to service manager
     */
    Zikula.define('Services');

    /**
     * Utility for managing polyfills.
     *
     * @namespace Zikula.Util.Polyfills Utility for managing polyfills.
     */
    Zikula.Util.Polyfills = (function(){
        /**
         * Internal storage for registered polyfills
         *
         * @type {Object}
         * @private
         */
        var polyfills = {};

        /**
         * Internal getter for polyfills.
         *
         * @private
         * @param {String}  name    Polufill name
         * @return {Object} Single polyfill object
         */
        function getPolyfill(name) {
            if (!_(polyfills).has(name)) {
                polyfills[name] = {
                    name: name,
                    deferred: new $.Deferred(),
                    loaded: false
                };
            }
            return polyfills[name];
        }

        /**
         * Add new Modernizr test for polyfill.
         * Result is accessed inside Modernizr as polyfill name suffixed with '-polyfill' (eg 'json-polyfill');
         *
         * @private
         * @param {String}              name    Polyfill name
         * @param {Function|Boolean}   [test]   Optional test for Modernizr (by default it's set to true)
         */
        function addTest(name, test) {
            test = _(test).isFunction() ? test : true;
            Modernizr.addTest(name+'-polyfill', test);
        }

        /**
         * Register new polyfill.
         *
         * Loading task is forwarded to yepnope and:
         * - document ready event is hold till polyfill will be resolved
         * - polyfill is registered into Modernizr under '$name-polyfill'
         * - observable deferred object is created for callbacks
         *
         * @example
         *  Zikula.Util.Polyfills.add('json', {
         *      test: Modernizr.json,
         *      nope: 'javascript/polyfills/json2/json2.js'
         *  });
         *
         * @name Zikula.Util.Polyfills.add
         * @function
         *
         * @param {String[]}    names       Polyfill name (or array of names)
         * @param {Object}      resource    Object for yepnope loader
         * @param {Function}   [test]       Optional test for Modernizr to register polyfill
         *
         * @return {Zikula.Util.Polyfills}
         */
        function add(names, resource, test) {
            names = _(names).isArray() ? names : [names];

            var resolver =  new $.Deferred(),
                complete = _(resource).objectGetPath('complete', $.noop);

            resolver.always(function() {
                complete();
                _(names).each(function(name) {
                    addTest(name, test);
                });
                $.holdReady(false);
            });
            resource.complete = resolver.resolve;

            $.holdReady(true);
            yepnope(resource);

            _(names).each(function(name) {
                var polyfill = getPolyfill(name);
                polyfill.loaded = true;
                resolver.done(polyfill.deferred.resolve);
            });

            return methods;
        }

        /**
         * Allows to bind callbacks to polyfill, which will be called when polyfill will be loaded
         * (or it is already loaded).
         *
         * Exports jQuery Deferred promise for requested polyfill, exposing Deferred methods (such as 'then' or 'done').
         * Due to the yepnope nature - returned promise will be always resolved (so using 'fail' method is pointless).
         * <a href="http://api.jquery.com/deferred.promise/">Read more about jQuery Deferred</a>
         *
         * @example
         *  Zikula.Util.Polyfills.when('json').then(doSomething); // doSomething will be executed after 'json' polyfill
         *                                                           will be loaded (or immediately if it's already loaded)
         *
         * @name Zikula.Util.Polyfills.when
         * @function
         *
         * @param {String} name Polyfill name
         * @return {jQuery.Deferred}
         */
        function when(name) {
            return getPolyfill(name).deferred.promise();
        }

        // Export public methods
        var methods = {
            add: add,
            when: when
        };
        return methods;
    })();

    // Load polyfills required by core
    Zikula.Util.Polyfills.add('json', {
        test: Modernizr.json,
        nope: 'javascript/polyfills/json2/json2.js'
    }).add(['localstorage', 'sessionstorage'], {
        test: Modernizr.localstorage && Modernizr.sessionstorage,
        nope: 'javascript/polyfills/storage/storage.js'
    });

})(jQuery);
// Copyright Zikula Foundation, licensed MIT.
/**
 * @fileOverview Cookie util
 * @requires underscore, core.js, class.js
 */
(function() {
    Zikula.define('Util');

    Zikula.Util.Cookie = Zikula.Class.create(/** @lends Zikula.Util.Cookie.prototype */{
        /**
         * Base util class for handling cookies.<br />
         * For standard usage use {@link Zikula.cookie} - already initialized instance
         * of {@link Zikula.Util.Cookie}
         *
         * @class Zikula.Util.Cookie
         * @constructs
         *
         * @param {Object}  [options]              Config object
         * @param {String}  [options.path='/']     Default path for cookies, if not set Zikula.Config.baseURI will be used
         * @param {String}  [options.domain='']    Domain for cookies, if not set current domain will be used
         * @param {Boolean} [options.secure=false] Should cookies be secured (transmitted over secure protocol as https)
         * @param {Boolean} [options.json=true]    Should cookies values be encoded to and decoded from json
         *
         * @return {Zikula.Util.Cookie} New Zikula.Util.Cookie instance
         */
        init: function(options) {
            this.options = _.extend(Zikula.Util.Cookie.options, options || { });

            return this;
        },
        /**
         * Create or update cookie.
         *
         * @param {String}       name     Cookie name.
         * @param {*}            value    Cookie value.
         * @param {Number|Date} [expires] Expiration date (Date object) or time in seconds, default is session.
         * @param {String}      [path]    Path for cookie, by default Zikula baseURI is set.
         *
         * @return {Boolean} Returns true on success, false otherwise
         */
        set: function(name, value, expires, path) {
            try {
                value = this.options.json ? this.encode(value) : value;
                var cookieStr = name + '=' + value,
                    cookieArgs = {
                        expires: expires instanceof Date ? expires.toGMTString() : this.secondsFromNow(expires),
                        path: path ? path : this.options.path,
                        domain: this.options.domain,
                        secure: this.options.secure ? 'secure' : ''
                    };
                _(cookieArgs).each(function(value, key, context) {
                    if (value) {
                        cookieStr += ';' + key + '=' + value;
                    }
                });

                document.cookie = cookieStr;
            } catch (e) {
                return false;
            }

            return true;
        },
        /**
         * Get cookie value.
         * Cookie value is returned in original format as it was stored.
         *
         * @param {String}  name Cookie name.
         * @param {Boolean} json Cookie name.
         *
         * @return {*} Returns cookie value or null.
         */
        get: function(name, json) {
            json = _(json).isUndefined() ? this.options.json : json;
            var cookie = new RegExp(name + '=(.*?)(;|$)').exec(document.cookie);

            return cookie ? (json ? this.decode(cookie[1]) : cookie[1]) : null;
        },
        /**
         * Delete cookie
         *
         * @param {String} name Cookie name.
         *
         * @return {Boolean} Returns true on success, false otherwise
         */
        remove: function(name) {
            return this.set(name, '', -1);
        },
        /**
         * Calculates date equal now plus given number of seconds
         *
         * @private
         * @param {Number} seconds Number of seconds
         *
         * @return {String} Date as GMT string
         */
        secondsFromNow: function(seconds) {
            if (!seconds) {
                return null;
            }
            var d = new Date();
            d.setTime(d.getTime() + (seconds * 1000));

            return d.toGMTString();
        },
        /**
         * Encode given value to format safe to store in cookies.
         * Due to PHPIDS original JSON format is encoded using encodeURI
         *
         * @private
         * @param {*} value Value to encode
         *
         * @return {String} Encoded value
         */
        encode: function(value) {
            return encodeURI(encodeURI(JSON.stringify(value)));
        },
        /**
         * Decode given string to original format
         *
         * @private
         * @param {String} value String to decode
         *
         * @return {*} Decoded value
         */
        decode: function(value) {
            return JSON.parse(decodeURI(decodeURI(value)));
        }
    });

    Zikula.Class.extend(Zikula.Util.Cookie, /** @lends Zikula.Util.Cookie */{
        /**
         * Default options for {@link Zikula.Util.Cookie}.
         * See <a href="#constructor">Zikula.Util.Cookie constructor</a> for details.
         *
         * @static
         */
        options: {
            path: '/',
            domain: '',
            secure: false,
            json: true
        }
    });

})();// Copyright Zikula Foundation, licensed MIT.
/**
 * @fileOverview Javascript Gettext implementation for Zikula.
 * @requires underscore, core.js, class.js
 */
(function() {
    Zikula.define('Util');

    Zikula.Util.Gettext = Zikula.Class.create(/** @lends Zikula.Util.Gettext.prototype */{
        /**
         * Regexp used for validating plural forms
         *
         * @private
         * @type RegExp
         */
        pluralsPattern: /^(nplurals=\d+;\s{0,}plural=[\s\d\w\(\)\?:%><=!&\|]+)\s{0,};\s{0,}$/i,
        /**
         * Null char used as delimiter for plural forms
         *
         * @private
         * @type String
         */
        nullChar: '\u0000',
        /**
         * Javascript Gettext implementation for Zikula.
         *
         * Base class for javascript gettext implementation. It runs internal and
         * exports utility methods to global Zikula object.
         * This are {@link Zikula.__}, {@link Zikula.__f}, {@link Zikula._n} and {@link Zikula._fn}.<br />
         * Usage is quite the same as PHP gettext
         *
         * @example
         * Zikula.__('hello','module_foo');
         * Zikula.__f('hello %s',['A'],'module_foo');
         * Zikula._n('hello my friend','hello my friends',2,'module_foo');
         * Zikula._fn('hello my friend %s','hello my friends %s',2,['A','B'],'module_foo')
         *
         * @class Zikula.Util.Gettext
         * @constructs
         *
         * @param {String} [lang] Language for translations
         * @param {Object} [data] Data with translations
         *
         * @return {Zikula.Util.Gettext} New Zikula.Util.Gettext instance
         */
        init: function(lang, data) {
            this.defaults = Zikula.Util.Gettext.options;

            this.data = {};
            this.setup(lang, data);

            this.__ = _(this.getMessage).bind(this);
            this.__f = _(this.getMessageFormatted).bind(this);
            this._n = _(this.getPluralMessage).bind(this);
            this._fn = _(this.getPluralMessageFormatted).bind(this);

            return this;
        },
        /**
         * Allows to re-init already initialized gettext instance
         *
         * @param {String}  lang    Language for translations
         * @param {Object}  data    Data with translations
         * @param {String} [domain] Default domain to use, optional
         *
         * @return void
         */
        setup: function(lang, data, domain) {
            this.setLang(lang);
            this.setDomain(domain);
            this.addTranslations(data || {});
        },
        /**
         * Adds translations to gettext instance
         *
         * @param {Object} obj Data with translations
         *
         * @return void
         */
        addTranslations: function(obj) {
            _(this.data).extendRecursive(obj);
        },
        /**
         * Setup current gettext language
         *
         * @param {String} lang   Language for translations
         *
         * @return void
         */
        setLang: function(lang) {
            this.lang = lang || this.defaults.lang;
        },
        /**
         * Setup current gettext default domain
         *
         * @param {String} domain Default domain to use, optional
         *
         * @return void
         */
        setDomain: function(domain) {
            this.domain = domain || this.defaults.domain;
        },
        /**
         * Reads from translations data
         *
         * @private
         * @param {String} domain The domain in which given key will be searched
         * @param {String} key    Data key to search
         *
         * @return {*} Given data key value or empty object
         */
        getData: function(domain, key) {
            domain = domain || this.domain;
            return _(this.data).objectGetPath([this.lang, domain, key].join('.'), {});
        },
        /**
         * Gettext: translates message.
         *
         * @example
         * Zikula.__('hello','module_foo');
         *
         * @param {String}  message The message to translate
         * @param {String} [domain] Gettext domain, if no domain is given default one is used
         *
         * @return {String} Translated message
         */
        getMessage: function(message, domain) {
            return this.getData(domain, 'translations')[message] || message;
        },
        /**
         * Gettext: translates and format message using sprintf formatting rules.
         *
         * @example
         * Zikula.__f('hello %s',['A'],'module_foo');
         *
         * @param {String}  message The message to translate
         * @param {Number}  params  Array with zero or more replacements to be made in message
         * @param {String} [domain] Gettext domain, if no domain is given deafult one is used
         *
         * @return {String} Translated message
         */
        getMessageFormatted: function(message, params, domain) {
            return _.vsprintf(this.getMessage(message, domain), params);
        },
        /**
         * Gettext: plural translation.
         *
         * @example
         * Zikula._n('hello my friend','hello my friends',2,'module_foo');
         *
         * @param {String}  singular  Singular message
         * @param {String}  plural    Plural message
         * @param {Number}  count     Count
         * @param {String} [domain]   Gettext domain, if no domain is given default one is used
         *
         * @return {String} Translated message
         */
        getPluralMessage: function(singular, plural, count, domain) {
            var offset = this.getPluralOffset(count, domain),
                key = singular + this.nullChar + plural,
                messages = this.getMessage(key, domain);
            if (messages) {
                return messages.split(this.nullChar)[offset];
            } else {
                return key.split(this.nullChar)[offset];
            }
        },
        /**
         * Gettext: plural formatted translation.
         *
         * @example
         * Zikula._fn('hello my friend %s','hello my friends %s',2,['A','B'],'module_foo')
         *
         * @param {String}  singular Singular message
         * @param {String}  plural   Plural message
         * @param {Number}  count    Count
         * @param {Array}   params   Array with zero or more replacements to be made in singular/plural message
         * @param {String} [domain]  Gettext domain, if no domain is given default one is used
         *
         * @return {String} Translated message
         */
        getPluralMessageFormatted: function(singular, plural, count, params, domain) {
            return _.vsprintf(this.getPluralMessage(singular, plural, count, domain), params);
        },
        /**
         * Calculates plural offset depending on plural forms
         *
         * @private
         * @param {Number} count  Count
         * @param {String} domain The domain to be used, if no domain is given default one is used
         *
         * @return {Number} Plural offset
         */
        getPluralOffset: function(count, domain) {
            var eq = null,
                nplurals = 0,
                plural = 0,
                n = count || 0;
            try {
                eq = this.getData(domain, 'plural-forms').match(this.pluralsPattern)[1];
                eval(eq);
            } catch (e) {
                eq = this.defaults.pluralForms;
                eval(eq);
            }
            if (plural >= nplurals) {
                plural = nplurals - 1;
            }
            return plural;
        }
    });

    Zikula.Class.extend(Zikula.Util.Gettext, /** @lends Zikula.Util.Gettext */{
        /**
         * Default options for {@link Zikula.Util.Gettext}.
         * See <a href="#constructor">Zikula.Util.Gettext constructor</a> for details.
         *
         * @static
         */
        options: {
            lang: 'en',
            domain: 'zikula_js',
            pluralForms: 'nplurals=2; plural=n == 1 ? 0 : 1;'
        }
    });
})();
// Copyright Zikula Foundation, licensed MIT.
/**
 * @fileOverview jQuery factory plugins
 * @requires jQuery, core.js, class.js
 */
(function($) {
    /**
     * Create simple jQuery plugin.
     *
     * @example
     * var Zikula.foo = function() {};
     * $.zPluginFactory('zFoo', Zikula.foo);
     * $('selector').zFoo(); // simple call
     * $('selector').zFoo(1, 'bar', [1,2,3]); // call with arguments for plugin
     *
     * @param {String}   pluginName Name for the plugin
     * @param {Function} plugin     Plugin function
     *
     * @return {Function} The plugin
     */
    jQuery.zPluginFactory = function(pluginName, plugin) {
        if (!plugin || !pluginName) {
            throw new Error('Invalid arguments');
        }
        $.fn[pluginName] = function() {
            var globalArgs = Array.prototype.slice.call(arguments);
            return this.map(function() { // use $.map not $.each, this let the plugin to control the return value
                var localArgs = $.extend(true, [], globalArgs);
                localArgs.unshift(this);
                return plugin.apply(this, localArgs);
            });
        };
        $.extend($.fn[pluginName], plugin); // copy plugin properties

        return $.fn[pluginName];
    };

    /**
     * Create stateful plugin (widget) with Zikula.Class.
     *
     * @example
     * var Zikula.Foo = Zikula.Class.create({});
     * $.zClassFactory('zFoo', Zikula.Foo);
     * $('selector').zFoo(); // calls class constructor
     * $('selector').zFoo('destroy'); // calls destroy method
     * $('selector').zFoo('foo', 1, 2); // calls foo method and passes some arguments
     *
     * @param  {String} klassName   Name for the class
     * @param  {Object} klass       Class object
     *
     * @return {Function} The plugin
     * todo - try to extend widget with class statics
     */
    jQuery.zClassFactory = function(klassName, klass) {
        if (!klass || !klassName) {
            throw new Error('Invalid arguments');
        }
        // define selector for plugin; use as $(':klassName')
        $.expr[":"][klassName] = function(elem) {
            return !!$.data(elem, klassName);
        };
        // factory function
        $.fn[klassName] =  function() {
            var globalArgs = Array.prototype.slice.call(arguments);
            return this.map(function() { // use $.map not $.each, this let the class to control the return value
                var localArgs = $.extend(true, [], globalArgs), // make a deep copy of globalArgs
                    result = this, // set default return value to keep chainability
                    instance = $(this).data(klassName); // try to get already instanced class
                if (instance instanceof klass) { // if instance exists - call its method
                    // get first arg - it should be method name - then call it and pass the rest of args
                    var method = localArgs.shift();
                    if (klass.hasMethod(method)) {
                        var localResult = instance[method].apply(instance, localArgs);
                        // here we make assumption that destroy method return value should evaluate to true on success
                        // if so - remove stored class data
                        if (method === 'destroy' && result) {
                            $(this).removeData(klassName);
                        }
                        // if method returned value other then itself - return this value instead of default
                        if (localResult !== instance) {
                            result = localResult;
                        }
                    }
                } else { // instance does not exist - call class constructor
                    // add $this as the first arg and send it to class constructor
                    if (!klass.hasMethod(localArgs[0])) { // skip calls to methods of uninstanced class
                        localArgs.unshift($(this));
                        $(this).data(klassName, Zikula.Class.construct(klass, localArgs));
                    }
                }
                return result;
            });
        };

        return $.fn[klassName];
    };

})(jQuery);// Copyright Zikula Foundation, licensed MIT.
/**
 * @fileOverview DOM utilities
 * @requires jQuery, underscore, core.js, factory.js
 */

(function($) {
    /**
     * Zikula DOM utilities.
     * Placeholder for Zikula's extensions for jQuery.
     *
     * @name Zikula.Dom
     * @namespace Zikula Dom namespace
     * @see jQuery.fn
     */
    Zikula.define('Dom');

    /**
     * Set odd/even classes on given list.
     *
     * @exports Zikula.Dom.recolor as jQuery.fn.zRecolor
     *
     * @example
     * Zikula.Dom.recolor($this, options); // base syntax
     * $($this).zRecolor(options); // jQuery syntax (recommended)
     * $('selector').zRecolor();
     * $('selector').zRecolor('.headerClass');
     * $('selector').zRecolor({
     *     header: '.headerClass',
     *     classes: 'oddClass evenClass'
     * });
     *
     * @param {HTMLElement}    $this    Single element from jQuery collection
     * @param {String|Object} [options] Selector for header or options object
     *
     * @return {HTMLElement}
     */
    Zikula.Dom.recolor = function($this) {
        var options = {};
        if (_(arguments[1]).isString()) {
            options.header = arguments[1];
        } else if (_(arguments[1]).isObject()) {
            options = arguments[1];
        }
        options = $.extend(true, Zikula.Dom.recolor.options, options);
        var classes = options.classes.split(' '),
            items = $($this).children(options.elements)
                .not(options.header)
                .removeClass(options.classes);
        items.filter(':odd').addClass(classes[0]);
        items.filter(':even').addClass(classes[1]);
        if (options.deep) {
            items.each(function(index, element) {
                Zikula.Dom.recolor(element, options);
            });
        }
        return $this;
    };
    Zikula.Dom.recolor.options = {
        elements: 'li',
        header: '',
        classes: 'z-odd z-even',
        deep: true
    };
    $.zPluginFactory('zRecolor', Zikula.Dom.recolor);

    /**
     * Allows to check, uncheck or toggle given checkbox or radio inputs.
     *
     * @exports Zikula.Dom.toggleInput as jQuery.fn.zToggleInput
     *
     * @example
     * Zikula.Dom.toggleInput($this, value); // base syntax
     * $($this).zToggleInput(value); // jQuery syntax (recommended)
     * $('form.class').zToggleInput();
     * $('form.class').zToggleInput(true);
     *
     * @param {HTMLElement}  $this       Single element from jQuery collection
     * @param {Boolean}     [value] True to check, false to uncheck. Leave undefined to toggle status
     *
     * @return {HTMLElement}
     */
    Zikula.Dom.toggleInput = function($this, value) {
        var setValue = _(value).isUndefined() ? function(v) {return !v;} : function(v) {return value;},
            iterate = function(index, element) {
                element = $(element);
                if (element.prop('nodeName') === 'INPUT') {
                    element.attr('checked', setValue(element.attr('checked')));
                } else {
                    element.find('input[type=radio],input[type=checkbox]').each(iterate);
                }
            };
        $($this).each(iterate);

        return $this;
    };

    $.zPluginFactory('zToggleInput', Zikula.Dom.toggleInput);

    /**
     * Change the display state of an specific container depending of an input value.
     *
     * @exports Zikula.Dom.displayWhen as jQuery.fn.zDisplayWhen
     *
     * @example
     * Zikula.Dom.displayWhen($this, input, value); // base syntax
     * $($this).zDisplayWhen(input, value); // jQuery syntax (recommended)
     * $('#container').zDisplayWhen('#checkbox', true);
     * $('#container').zDisplayWhen('[name[radio_group]', true);
     * $('#container').zDisplayWhen('#input_parent_element', true);
     *
     * @param {HTMLElement}        $this Single element from jQuery collection
     * @param {HTMLElement|String} input Selector for input, inputs group or theirs container
     * @param {*}                  value Input value to trigger container display
     *
     * @return {HTMLElement}
     */
    Zikula.Dom.displayWhen = function($this, input, value) {
        value = _(value).isUndefined() ? true : value;
        input = $(input);

        if (input.prop('nodeName') !== 'INPUT') {
            input = input.find('input[type=radio],input[type=checkbox]');
        }

        if (input.filter(':checked').val() == value) {
            $($this).slideDown();
        } else {
            $($this).slideUp();
        }

        return $this;
    };
    $.zPluginFactory('zDisplayWhen', Zikula.Dom.displayWhen);
})(jQuery);// Copyright Zikula Foundation, licensed MIT.
/**
 * @fileOverview Ajax utils
 * @requires jQuery, underscore, core.js, class.js
 */
(function($) {
    /**
     * Zikula Ajax namespace
     *
     * @name Zikula.Ajax
     * @namespace Zikula Ajax namespace
     */
    Zikula.define('Ajax');

    Zikula.Ajax.Response = Zikula.Class.create(/** @lends Zikula.Ajax.Response.prototype */{
        /**
         * Custom handler for jQuery ajax request and response objects.
         * It's recommended to obtain data from response using this methods rather than
         * reading responseText directly.
         *
         * @class Zikula.Ajax.Response
         * @constructs
         *
         * @param {Object} request  jQuery request object
         * @param {Object} response jQuery response object (jqXHR)
         *
         * @return {Zikula.Ajax.Response} New Zikula.Ajax.Response instance
         */
        init: function(request, response) {
            this.request = function() {
                return request;
            };
            this.response = function() {
                return response;
            };

            return this;
        },
        /**
         * Get status or error messages from response
         * Note - it is possible to get more then one message from response, so this method
         * may return simple string or object with numeric keys and multiple messages.
         *
         * @return {String|Object} Message or object with multiple messages
         */
        getMessage: function() {
            return _(this.decodeResponse()).objectGetPath('core.statusmsg', null);

        },
        /**
         * Get data returned by module controller
         *
         * @return {*} Data returned by module controller
         */
        getData: function() {
            return this.decodeResponse().data;
        },
        /**
         * Get core data from response
         *
         * @private
         *
         * @return {*}
         */
        getCoreData: function() {
            return this.decodeResponse().core;
        },
        /**
         * Tests whether the request was successful.
         *
         * @return {Boolean} True on success, false otherwise
         */
        isSuccess: function() {
            var status = this.response().status;
            return status >= 200 && status < 300 || status === 304;
        },
        /**
         * Decodes responseText
         *
         * @private
         *
         * @param {Boolean} [force=false] True to skip cache
         *
         * @return {Object} Decoded response text
         */
        decodeResponse: function(force) {
            if (!this.result || force) {
                var responseText = this.response().responseText,
                    response;
                try {
                    if (_(responseText).isJSON()) {
                        response = jQuery.parseJSON(responseText);
                        this.result = {
                            data: response.data || responseText,
                            core: response.core || null
                        };
                    }
                } catch (e) {
                    this.result = {
                        data: responseText || null,
                        core: null
                    };
                }
            }

            return this.result;
        }
    });
    Zikula.Class.extend(Zikula.Ajax.Response, /** @lends Zikula.Ajax.Response.prototype */{
        /**
         * Converter function for standard Zikula ajax responses.
         * It's registered for 'text json' data type and checks if responseText contains expected properties (core and data).
         *
         * @static
         *
         * @return {Object} Decoded response text
         */
        convertResponseText: function(responseText) {
            var response = jQuery.parseJSON(responseText);
            if (_(response).objectIssetPath('core') && _(response).objectIssetPath('data')) {
                response = response.data;
            }
            return response;
        }
    });

})(jQuery);
// Copyright Zikula Foundation, licensed MIT.
/**
 * @fileOverview Bootstrap for Zikula javascript
 * @requires jQuery, underscore, zikula.js, lang.js, core.js, class.js, factory.js, util.cookie.js, util.gettext.js, dom.js, ajax.js
 */
/**
 * Global Zikula config object.
 * Zikula.Config is defined inline in HTML HEAD and is always avaiable.<br >
 * Contains following properties:<br >
 * - entrypoint<br >
 * - baseURL<br >
 * - baseURI<br >
 * - ajaxtimeout<br >
 * - lang
 *
 * @name Zikula.Config
 */

/**
 * jQuery object (dummy doc stub for extensions)
 * @name jQuery
 * @class
 * @see <a href="http://api.jquery.com/">http://api.jquery.com/</a>
 */

/**
 * jQuery object (dummy doc stub for extensions)
 * @name fn
 * @class
 * @memberOf jQuery
 * @see <a href="http://api.jquery.com/">http://api.jquery.com/</a>
 */
(function($) {
    /**
     * Gettext service.
     * This is internal service - unless necessary use shortcuts exposed in Zikula namespace
     *
     * @see Zikula.Util.Gettext
     * @type {Zikula.Util.Gettext}
     */
    Zikula.Services.gettext = new Zikula.Util.Gettext(Zikula.Config.lang, Zikula._translations);

    // Export shortcuts to Zikula global object.
    Zikula.Class.extend(Zikula, {
        __: Zikula.Services.gettext.__,
        __f: Zikula.Services.gettext.__f,
        _n: Zikula.Services.gettext._n,
        _fn: Zikula.Services.gettext._fn
    });

    // make sure json support is assured before using cookie util
    Zikula.Util.Polyfills.when('json').then(function(){
        /**
         * Cookie service.
         * Initialized with default settings Zikula.Util.Cookie class.
         * See Zikula.Util.Cookie for reference.
         *
         * @see Zikula.Util.Cookie
         * @type {Zikula.Util.Cookie}
         */
        Zikula.Services.cookie = new Zikula.Util.Cookie({
            path: Zikula.Config.baseURI
        });

        // Set ajax options
        Zikula.Ajax.defaultOptions = {
            type: 'POST',
            timeout: Zikula.Config.ajaxtimeout || 5000,
            converters: {
                "text json": Zikula.Ajax.Response.convertResponseText
            }
        };
        if (Zikula.Config.sessionName) {
            var sessionId = Zikula.Services.cookie.get(Zikula.Config.sessionName, false);
            if (sessionId) {
                Zikula.Ajax.defaultOptions.headers = {
                    'X-ZIKULA-AJAX-TOKEN': sessionId
                };
            }
        }
        $.ajaxSetup(Zikula.Ajax.defaultOptions);

        // Use prefilter to extend jQuery request and response object with Zikula.Ajax.Response
        $.ajaxPrefilter(function(options, originalOptions, jqXHR) {
            var response = new Zikula.Ajax.Response(options, jqXHR);
            $.extend(options, {
                zikula: response
            });
            $.extend(jqXHR, {
                zikula: response
            });
        });
    });
})(jQuery);
